# Story 2.2: User Login & JWT Token Generation

**Epic:** Epic 2 - Authentication & User System
**Story ID:** 2.2
**Priority:** High
**Estimate:** 5 Story Points
**Sprint:** Sprint 2-3 (Week 3-4)

---

## Status

**Ready for Development**

---

## Dependencies

- **Story 2.1**: User Registration API (ต้องมี user table และ auth module)
- **Story 1.3**: Database Setup (ต้องมี Prisma และ database connection)
- **Story 1.4**: NestJS Backend Setup (ต้องมี NestJS app พร้อมใช้งาน)

---

## Story

**As a** registered user,
**I want** to log in with my email and password,
**so that** I can access my account and protected features

---

## Acceptance Criteria

1. `POST /v1/auth/login` endpoint created
2. Request validation:
   - Email: required, valid format
   - Password: required
3. Authentication logic:
   - Find user by email (case-insensitive)
   - Verify password using bcrypt
   - Generate JWT tokens on success
4. JWT tokens generated:
   - Access token: RS256, 15 minutes TTL, contains userId and email
   - Refresh token: RS256, 7 days TTL, contains userId only
5. Response includes:
   - Access token
   - Refresh token
   - User data (without password)
6. Error handling:
   - 401 for invalid credentials
   - 400 for validation errors
7. Rate limiting considered (document for Phase 2)
8. Unit and integration tests cover success and failure cases

---

## Tasks / Subtasks

- [ ] **Install JWT Dependencies** (AC: 4)
  - [ ] Install JWT module: `pnpm add @nestjs/jwt @nestjs/passport passport passport-jwt`
  - [ ] Install types: `pnpm add -D @types/passport-jwt`
  - [ ] Verify installations in package.json

- [ ] **Generate RSA Key Pair** (AC: 4)
  - [ ] Generate private key: `openssl genrsa -out apps/backend/private.key 2048`
  - [ ] Generate public key: `openssl rsa -in apps/backend/private.key -pubout -out apps/backend/public.key`
  - [ ] Add keys to .gitignore (พวกมันเป็น secrets)
  - [ ] Document key generation process

- [ ] **Create JWT Configuration** (AC: 4)
  - [ ] Create `src/auth/config/jwt.config.ts`
  - [ ] Configure JWT module with RS256 algorithm
  - [ ] Set access token expiration to 15 minutes
  - [ ] Set refresh token expiration to 7 days
  - [ ] Import key paths from environment variables

- [ ] **Create Login DTO** (AC: 2)
  - [ ] Create `src/auth/dto/login.dto.ts`
  - [ ] Import LoginSchema from @recipe-wire/types
  - [ ] Define LoginDto class with validation decorators
  - [ ] Add email and password fields
  - [ ] Export DTO

- [ ] **Create JWT Payload Interface** (AC: 4)
  - [ ] Create `src/auth/interfaces/jwt-payload.interface.ts`
  - [ ] Define JwtPayload with userId, email, iat, exp
  - [ ] Define RefreshTokenPayload with userId only
  - [ ] Export interfaces

- [ ] **Implement Login Logic in Auth Service** (AC: 3, 4, 5)
  - [ ] Create `login` method accepting LoginDto
  - [ ] Find user by email (case-insensitive)
  - [ ] Verify password using comparePassword utility
  - [ ] Generate access and refresh tokens on success
  - [ ] Return tokens and sanitized user data
  - [ ] Add logging for login attempts

- [ ] **Implement JWT Token Generation** (AC: 4)
  - [ ] Create `generateTokens` method in AuthService
  - [ ] Use JwtService to sign access token with user payload
  - [ ] Use JwtService to sign refresh token with userId only
  - [ ] Set appropriate expiration times
  - [ ] Return both tokens

- [ ] **Implement Login Endpoint in Auth Controller** (AC: 1, 6)
  - [ ] Create POST /auth/login endpoint
  - [ ] Add @Post('login') decorator
  - [ ] Accept @Body() with LoginDto
  - [ ] Call authService.login()
  - [ ] Return 200 OK with tokens and user data
  - [ ] Add error handling with try-catch

- [ ] **Implement Rate Limiting Documentation** (AC: 7)
  - [ ] Document rate limiting requirements for Phase 2
  - [ ] Specify 5 login attempts per minute per IP
  - [ ] Document lockout after failed attempts

- [ ] **Create Unit Tests** (AC: 8)
  - [ ] Test login with valid credentials
  - [ ] Test login with invalid email
  - [ ] Test login with wrong password
  - [ ] Test JWT token generation
  - [ ] Test token expiration settings
  - [ ] Test error scenarios

- [ ] **Create Integration Tests** (AC: 8)
  - [ ] Test complete login API endpoint
  - [ ] Verify token generation and response format
  - [ ] Test authentication failure scenarios
  - [ ] Verify user data sanitization

---

## Dev Notes

### JWT Configuration

**Environment Variables:**
```bash
# JWT Configuration
JWT_ACCESS_TOKEN_EXPIRES_IN=15m
JWT_REFRESH_TOKEN_EXPIRES_IN=7d
JWT_PRIVATE_KEY_PATH=apps/backend/private.key
JWT_PUBLIC_KEY_PATH=apps/backend/public.key
```

**JWT Module Configuration:**
```typescript
JwtModule.registerAsync({
  useFactory: (configService: ConfigService) => ({
    privateKey: configService.get<string>('JWT_PRIVATE_KEY_PATH'),
    publicKey: configService.get<string>('JWT_PUBLIC_KEY_PATH'),
    signOptions: {
      algorithm: 'RS256',
      expiresIn: configService.get<string>('JWT_ACCESS_TOKEN_EXPIRES_IN'),
    },
  }),
  inject: [ConfigService],
})
```

### API Contract

**Endpoint:** `POST /v1/auth/login`

**Request Body:**
```typescript
{
  email: string;    // User's email address
  password: string; // User's password
}
```

**Response:**
```typescript
{
  accessToken: string;   // JWT access token (15 minutes TTL)
  refreshToken: string;  // JWT refresh token (7 days TTL)
  user: {
    id: string;
    email: string;
    displayName: string;
    bio?: string;
    avatarUrl?: string;
    createdAt: string;
  };
}
```

### Token Payload Structure

**Access Token Payload:**
```typescript
{
  userId: string;   // User's unique identifier
  email: string;    // User's email address
  iat: number;      // Issued at timestamp
  exp: number;      // Expiration timestamp
}
```

**Refresh Token Payload:**
```typescript
{
  userId: string;   // User's unique identifier only
  iat: number;      // Issued at timestamp
  exp: number;      // Expiration timestamp
}
```

### Security Considerations

- **Token Security**: RS256 algorithm with RSA key pair
- **Short-lived Access**: 15 minutes prevents long-term exposure
- **Refresh Rotation**: Consider implementing refresh token rotation
- **Rate Limiting**: Document for Phase 2 (5 attempts/minute)
- **Account Lockout**: Consider implementing after failed attempts
- **Logging**: Log login attempts without passwords

### Error Messages

- `400 Bad Request`: \"Email and password are required\"
- `400 Bad Request`: \"Invalid email format\"
- `401 Unauthorized`: \"Invalid credentials\"
- `429 Too Many Requests`: \"Too many login attempts\" (Phase 2)
- `500 Internal Server Error`: \"Login failed. Please try again.\"

### Testing Strategy

**Unit Tests:**
- Password verification logic
- JWT token generation
- Token payload structure
- Error handling scenarios

**Integration Tests:**
- Complete login flow
- Token validation
- Response format verification
- Error response handling

**Security Tests:**
- Token signature verification
- Token expiration handling
- No sensitive data in responses

---

## References

- **PRD**: docs/prd/epic-2-authentication.md#story-2.2
- **Architecture**: docs/architecture/coding-standards.md#jwt-implementation
- **Tech Stack**: docs/architecture/tech-stack.md#nestjs-jwt

---

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-09-30 | 1.0     | Enhanced story with comprehensive JWT implementation details | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used

Enhanced NestJS JWT authentication with RS256 signing and comprehensive token management

### Debug Log References

JWT service logs, token generation verification, and authentication attempt logs

### Completion Notes List

1. Enhanced with detailed JWT configuration and token management
2. Added comprehensive security considerations and error handling
3. Included detailed API contracts and token payload specifications
4. Added testing strategy with unit and integration tests
5. Documented rate limiting and security best practices

### File List

- apps/backend/src/auth/config/jwt.config.ts
- apps/backend/src/auth/dto/login.dto.ts
- apps/backend/src/auth/interfaces/jwt-payload.interface.ts
- apps/backend/src/auth/auth.service.ts (updated with login logic)
- apps/backend/src/auth/auth.controller.ts (updated with login endpoint)
- apps/backend/package.json (updated with JWT dependencies)
- apps/backend/private.key (generated)
- apps/backend/public.key (generated)
- Tests files for unit and integration testing

---

## QA Results

_Enhanced story ready for QA review and development implementation_
  - [ ] Add keys to .env: JWT_PRIVATE_KEY, JWT_PUBLIC_KEY
  - [ ] Add keys to .env.example (with instructions)
  - [ ] Document key generation process in README

- [ ] **Configure JWT Module** (AC: 4)
  - [ ] Import JwtModule in AuthModule
  - [ ] Configure with RS256 algorithm
  - [ ] Set private key from environment
  - [ ] Set access token expiration: 15m
  - [ ] Set refresh token expiration: 7d
  - [ ] Export JwtService for use in AuthService

- [ ] **Create Login DTO** (AC: 2)
  - [ ] Create `src/auth/dto/login.dto.ts`
  - [ ] Define LoginSchema in @recipe-wire/types
  - [ ] Add email and password fields
  - [ ] Add Zod validation (email format, required fields)
  - [ ] Export DTO

- [ ] **Create Token Response DTO** (AC: 5)
  - [ ] Create `src/auth/dto/token-response.dto.ts`
  - [ ] Define interface with accessToken, refreshToken, user
  - [ ] Export DTO

- [ ] **Implement Token Generation Service** (AC: 4)
  - [ ] Create `src/auth/utils/token.util.ts`
  - [ ] Implement generateAccessToken function
  - [ ] Implement generateRefreshToken function
  - [ ] Set payload: { userId, email } for access token
  - [ ] Set payload: { userId } for refresh token
  - [ ] Add iat (issued at) and exp (expiration) claims
  - [ ] Export functions

- [ ] **Implement Auth Service - Login Logic** (AC: 3, 4, 5)
  - [ ] Inject JwtService in AuthService
  - [ ] Create `login` method accepting LoginDto
  - [ ] Find user by email (case-insensitive)
  - [ ] Throw UnauthorizedException if user not found
  - [ ] Verify password using comparePassword utility
  - [ ] Throw UnauthorizedException if password incorrect
  - [ ] Generate access and refresh tokens
  - [ ] Return tokens and sanitized user object
  - [ ] Add logging for login attempts (success/failure)

- [ ] **Implement Auth Controller - Login Endpoint** (AC: 1, 6)
  - [ ] Create POST /auth/login endpoint
  - [ ] Add @Post('login') decorator
  - [ ] Accept @Body() with LoginDto
  - [ ] Call authService.login()
  - [ ] Return 200 OK with tokens and user data
  - [ ] Add error handling with try-catch
  - [ ] Map exceptions to appropriate HTTP status codes

- [ ] **Implement Error Handling** (AC: 6)
  - [ ] Handle invalid credentials → 401 Unauthorized
  - [ ] Handle validation errors → 400 Bad Request
  - [ ] Return consistent error response format
  - [ ] Do not reveal whether email or password is wrong (security)
  - [ ] Log failed login attempts with email (for monitoring)

- [ ] **Add Security Headers** (AC: 7)
  - [ ] Document rate limiting requirement for Phase 2
  - [ ] Add TODO comment for rate limiting implementation
  - [ ] Consider adding helmet middleware for security headers
  - [ ] Document brute force protection strategy

- [ ] **Create Unit Tests** (AC: 8)
  - [ ] Create `auth.service.spec.ts` (login tests)
  - [ ] Test successful login returns tokens
  - [ ] Test invalid email returns 401
  - [ ] Test invalid password returns 401
  - [ ] Test password verification
  - [ ] Test token generation
  - [ ] Mock PrismaService and JwtService
  - [ ] Achieve 80%+ coverage

- [ ] **Create Integration Tests** (AC: 8)
  - [ ] Create `test/auth.integration.spec.ts` (login tests)
  - [ ] Setup test user in database
  - [ ] Test POST /v1/auth/login with valid credentials
  - [ ] Verify tokens returned
  - [ ] Verify user data returned (without password)
  - [ ] Test invalid email returns 401
  - [ ] Test invalid password returns 401
  - [ ] Test case-insensitive email lookup
  - [ ] Cleanup test data after each test

- [ ] **Update API Documentation** (AC: 1)
  - [ ] Document POST /v1/auth/login endpoint
  - [ ] Document request body schema
  - [ ] Document response format (tokens + user)
  - [ ] Document error responses
  - [ ] Add example requests and responses
  - [ ] Document token expiration times

---

## Dev Notes

### Previous Story Insights

[Dependency: Story 2.1 - User Registration API]

Story 2.1 established:

- User model with email and passwordHash
- Password hashing with bcrypt
- Auth module, service, and controller structure
- Signup endpoint with validation

This story adds login functionality with JWT token generation.

### JWT Configuration

[Source: architecture/tech-stack.md#jwt]

**JWT (JSON Web Tokens)** for stateless authentication:

- Algorithm: RS256 (RSA Signature with SHA-256)
- Access Token: 15 minutes TTL
- Refresh Token: 7 days TTL
- No sensitive data in JWT payload

**Libraries:**

- `@nestjs/jwt`: NestJS JWT module
- `passport-jwt`: Passport strategy for JWT

**Installation:**

```bash
pnpm add @nestjs/jwt @nestjs/passport passport passport-jwt
pnpm add -D @types/passport-jwt
```

### RSA Key Pair Generation

[Source: prd/epic-2-authentication.md#story-2.2]

**Generate keys:**

```bash
# Generate private key
openssl genrsa -out private.key 2048

# Generate public key
openssl rsa -in private.key -pubout -out public.key

# Convert to base64 for environment variables (optional)
cat private.key | base64
cat public.key | base64
```

**Store in .env:**

```
JWT_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----"
JWT_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----"
JWT_ACCESS_EXPIRATION=15m
JWT_REFRESH_EXPIRATION=7d
```

### JWT Module Configuration

[Source: architecture/tech-stack.md#jwt]

**Configure in AuthModule:**

```typescript
import { Module } from '@nestjs/common'
import { JwtModule } from '@nestjs/jwt'
import { ConfigService } from '@nestjs/config'

@Module({
  imports: [
    JwtModule.registerAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        privateKey: config.get('JWT_PRIVATE_KEY'),
        publicKey: config.get('JWT_PUBLIC_KEY'),
        signOptions: {
          algorithm: 'RS256',
          expiresIn: config.get('JWT_ACCESS_EXPIRATION') || '15m',
        },
      }),
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService],
})
export class AuthModule {}
```

### Login DTO and Validation

[Source: prd/epic-2-authentication.md#story-2.2]

**Zod schema (packages/types/src/auth/auth.schemas.ts):**

```typescript
export const LoginSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(1, 'Password is required'),
})

export type LoginDto = z.infer<typeof LoginSchema>
```

**NestJS DTO:**

```typescript
import { LoginSchema } from '@recipe-wire/types'
import { createZodDto } from 'nestjs-zod'

export class LoginDto extends createZodDto(LoginSchema) {}
```

### Token Generation

[Source: prd/epic-2-authentication.md#story-2.2]

**Token utilities (src/auth/utils/token.util.ts):**

```typescript
import { JwtService } from '@nestjs/jwt'

export function generateAccessToken(jwtService: JwtService, userId: string, email: string): string {
  return jwtService.sign({ userId, email }, { expiresIn: '15m' })
}

export function generateRefreshToken(jwtService: JwtService, userId: string): string {
  return jwtService.sign({ userId }, { expiresIn: '7d' })
}
```

### Auth Service Login Implementation

[Source: architecture/coding-standards.md#nestjs-best-practices]

**AuthService login method:**

```typescript
import { Injectable, UnauthorizedException, Logger } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { PrismaService } from '../prisma/prisma.service'
import { LoginDto } from './dto/login.dto'
import { comparePassword } from './utils/password.util'

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name)

  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService
  ) {}

  async login(dto: LoginDto) {
    const { email, password } = dto

    // Find user by email
    const user = await this.prisma.user.findUnique({
      where: { email: email.toLowerCase() },
    })

    if (!user) {
      this.logger.warn(`Login attempt failed: user not found (${email})`)
      throw new UnauthorizedException('Invalid credentials')
    }

    // Verify password
    const isPasswordValid = await comparePassword(password, user.passwordHash)

    if (!isPasswordValid) {
      this.logger.warn(`Login attempt failed: invalid password (${email})`)
      throw new UnauthorizedException('Invalid credentials')
    }

    // Generate tokens
    const accessToken = this.jwtService.sign(
      { userId: user.id, email: user.email },
      { expiresIn: '15m' }
    )

    const refreshToken = this.jwtService.sign({ userId: user.id }, { expiresIn: '7d' })

    this.logger.log(`User logged in: ${user.email}`)

    // Return tokens and user (without password)
    const { passwordHash: _, ...userWithoutPassword } = user

    return {
      accessToken,
      refreshToken,
      user: userWithoutPassword,
    }
  }
}
```

### Auth Controller Login Endpoint

[Source: architecture/coding-standards.md#nestjs-best-practices]

**AuthController login endpoint:**

```typescript
@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  @HttpCode(HttpStatus.OK)
  async login(@Body() dto: LoginDto) {
    return this.authService.login(dto)
  }
}
```

### JWT Token Payload

[Source: prd/epic-2-authentication.md#story-2.2]

**Access Token Payload:**

```typescript
{
  userId: "550e8400-e29b-41d4-a716-446655440000",
  email: "user@example.com",
  iat: 1696089600,  // Issued at timestamp
  exp: 1696090500   // Expiration timestamp (15 min later)
}
```

**Refresh Token Payload:**

```typescript
{
  userId: "550e8400-e29b-41d4-a716-446655440000",
  iat: 1696089600,  // Issued at timestamp
  exp: 1696694400   // Expiration timestamp (7 days later)
}
```

### Success Response Format

[Source: prd/epic-2-authentication.md#story-2.2]

**Login success response:**

```typescript
{
  "accessToken": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "user@example.com",
    "displayName": "John Doe",
    "bio": null,
    "avatarUrl": null,
    "createdAt": "2025-09-30T10:00:00.000Z",
    "updatedAt": "2025-09-30T10:00:00.000Z"
  }
}
```

### Security Considerations

[Source: prd/epic-2-authentication.md#security-considerations]

**Authentication security:**

- Use generic error message "Invalid credentials" (don't reveal if email or password is wrong)
- Log failed login attempts for monitoring
- Use RS256 algorithm (asymmetric) for better security
- Keep access tokens short-lived (15 minutes)
- Never log passwords or tokens
- Consider rate limiting for Phase 2 (document requirement)

**Rate Limiting (Phase 2):**

- Implement rate limiting on /auth/login endpoint
- Limit to 5 attempts per IP per 15 minutes
- Consider account lockout after multiple failed attempts
- Use @nestjs/throttler package

### Testing

[Source: architecture/coding-standards.md#testing-standards]

**Unit Tests:**

```typescript
describe('AuthService - login', () => {
  it('should return tokens and user for valid credentials', async () => {
    // Test implementation
  })

  it('should throw UnauthorizedException for invalid email', async () => {
    // Test implementation
  })

  it('should throw UnauthorizedException for invalid password', async () => {
    // Test implementation
  })

  it('should perform case-insensitive email lookup', async () => {
    // Test implementation
  })

  it('should generate valid JWT tokens', async () => {
    // Test implementation
  })
})
```

**Integration Tests:**

```typescript
describe('POST /v1/auth/login', () => {
  beforeEach(async () => {
    // Create test user
    await createUser({
      email: 'test@example.com',
      password: 'Password123',
      displayName: 'Test User',
    })
  })

  it('should login and return tokens', async () => {
    const response = await request(app.getHttpServer())
      .post('/v1/auth/login')
      .send({
        email: 'test@example.com',
        password: 'Password123',
      })
      .expect(200)

    expect(response.body).toHaveProperty('accessToken')
    expect(response.body).toHaveProperty('refreshToken')
    expect(response.body.user.email).toBe('test@example.com')
    expect(response.body.user).not.toHaveProperty('passwordHash')
  })

  it('should return 401 for invalid email', async () => {
    await request(app.getHttpServer())
      .post('/v1/auth/login')
      .send({
        email: 'wrong@example.com',
        password: 'Password123',
      })
      .expect(401)
  })

  it('should return 401 for invalid password', async () => {
    await request(app.getHttpServer())
      .post('/v1/auth/login')
      .send({
        email: 'test@example.com',
        password: 'WrongPassword',
      })
      .expect(401)
  })

  it('should handle case-insensitive email', async () => {
    await request(app.getHttpServer())
      .post('/v1/auth/login')
      .send({
        email: 'TEST@EXAMPLE.COM',
        password: 'Password123',
      })
      .expect(200)
  })
})
```

---

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-09-30 | 1.0     | Initial story creation | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent during implementation_

### Debug Log References

_To be filled by Dev Agent during implementation_

### Completion Notes List

_To be filled by Dev Agent during implementation_

### File List

_To be filled by Dev Agent during implementation_

---

## QA Results

_To be filled by QA Agent after implementation_
