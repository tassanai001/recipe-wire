# Story 2.4: User Profile Management API

**Epic:** Epic 2 - Authentication & User System  
**Story ID:** 2.4  
**Priority:** Medium  
**Estimate:** 3 Story Points  
**Sprint:** Sprint 2-3 (Week 3-4)

---

## Status

**Draft**

---

## Story

**As a** logged-in user,  
**I want** to view and update my profile information,  
**so that** I can personalize my account

---

## Acceptance Criteria

1. `GET /v1/me` endpoint created (protected):
   - Returns current user profile
   - Excludes password hash
2. `PATCH /v1/me` endpoint created (protected):
   - Allows updating: displayName, bio, avatarUrl
   - Validates input:
     - Display name: 2-50 characters
     - Bio: max 500 characters
     - Avatar URL: valid URL format
   - Returns updated user profile
3. User cannot update email or password (document separate endpoints for Phase 2)
4. Error handling:
   - 401 for unauthenticated requests
   - 400 for validation errors
5. Unit tests cover validation scenarios
6. Integration tests verify profile updates

---

## Tasks / Subtasks

- [ ] **Create Users Module** (AC: 1, 2)
  - [ ] Run `nest g module users`
  - [ ] Run `nest g controller users`
  - [ ] Run `nest g service users`
  - [ ] Import UsersModule in AppModule

- [ ] **Create Update Profile DTO** (AC: 2)
  - [ ] Create `src/users/dto/update-profile.dto.ts`
  - [ ] Define UpdateProfileSchema in @recipe-wire/types
  - [ ] Add optional fields: displayName, bio, avatarUrl
  - [ ] Add validation rules for each field
  - [ ] Export DTO

- [ ] **Implement Users Service** (AC: 1, 2)
  - [ ] Inject PrismaService in UsersService
  - [ ] Create `getProfile` method accepting userId
  - [ ] Query user by ID
  - [ ] Return user without passwordHash
  - [ ] Create `updateProfile` method accepting userId and UpdateProfileDto
  - [ ] Update user in database
  - [ ] Return updated user without passwordHash
  - [ ] Add logging for profile updates

- [ ] **Implement Users Controller - Get Profile** (AC: 1)
  - [ ] Create GET /me endpoint
  - [ ] Use @CurrentUser() decorator to get user
  - [ ] Call usersService.getProfile(user.id)
  - [ ] Return user profile
  - [ ] Endpoint is automatically protected by global JWT guard

- [ ] **Implement Users Controller - Update Profile** (AC: 2, 4)
  - [ ] Create PATCH /me endpoint
  - [ ] Use @CurrentUser() decorator to get user
  - [ ] Accept @Body() with UpdateProfileDto
  - [ ] Call usersService.updateProfile(user.id, dto)
  - [ ] Return updated user profile
  - [ ] Handle validation errors → 400 Bad Request

- [ ] **Add Validation Logic** (AC: 2)
  - [ ] Validate displayName: 2-50 characters
  - [ ] Validate bio: max 500 characters (optional)
  - [ ] Validate avatarUrl: valid URL format (optional)
  - [ ] Use Zod schema for validation
  - [ ] Return clear error messages for validation failures

- [ ] **Document Email/Password Update** (AC: 3)
  - [ ] Add TODO comment for email update endpoint (Phase 2)
  - [ ] Add TODO comment for password change endpoint (Phase 2)
  - [ ] Document in README that email/password updates are Phase 2
  - [ ] Consider security implications (email verification, password confirmation)

- [ ] **Create Unit Tests** (AC: 5)
  - [ ] Test getProfile returns user without password
  - [ ] Test updateProfile with valid data
  - [ ] Test updateProfile validation (displayName too short)
  - [ ] Test updateProfile validation (bio too long)
  - [ ] Test updateProfile validation (invalid URL)
  - [ ] Test updateProfile with partial updates
  - [ ] Mock PrismaService

- [ ] **Create Integration Tests** (AC: 6)
  - [ ] Test GET /v1/me returns current user
  - [ ] Test GET /v1/me requires authentication
  - [ ] Test PATCH /v1/me updates displayName
  - [ ] Test PATCH /v1/me updates bio
  - [ ] Test PATCH /v1/me updates avatarUrl
  - [ ] Test PATCH /v1/me with invalid displayName returns 400
  - [ ] Test PATCH /v1/me with invalid bio returns 400
  - [ ] Test PATCH /v1/me requires authentication
  - [ ] Verify database updates persist

- [ ] **Update API Documentation** (AC: 1, 2)
  - [ ] Document GET /v1/me endpoint
  - [ ] Document PATCH /v1/me endpoint
  - [ ] Document request/response schemas
  - [ ] Document validation rules
  - [ ] Add example requests and responses

---

## Dev Notes

### Previous Story Insights

[Dependency: Story 2.3 - JWT Authentication Guard & Token Refresh]

Story 2.3 established:

- JWT authentication guard protecting routes
- @CurrentUser() decorator to access authenticated user
- Public vs protected route configuration

This story creates profile management endpoints that use the authentication system.

### Users Module Structure

[Source: architecture/source-tree.md#backend-module-pattern]

**Users module structure:**

```
src/users/
├── dto/
│   └── update-profile.dto.ts
├── users.controller.ts
├── users.service.ts
└── users.module.ts
```

### Update Profile DTO

[Source: prd/epic-2-authentication.md#story-2.4]

**Zod schema (packages/types/src/auth/user.schemas.ts):**

```typescript
import { z } from 'zod'

export const UpdateProfileSchema = z.object({
  displayName: z
    .string()
    .min(2, 'Display name must be at least 2 characters')
    .max(50, 'Display name must not exceed 50 characters')
    .optional(),
  bio: z.string().max(500, 'Bio must not exceed 500 characters').optional(),
  avatarUrl: z.string().url('Avatar URL must be a valid URL').optional(),
})

export type UpdateProfileDto = z.infer<typeof UpdateProfileSchema>
```

**NestJS DTO:**

```typescript
import { UpdateProfileSchema } from '@recipe-wire/types'
import { createZodDto } from 'nestjs-zod'

export class UpdateProfileDto extends createZodDto(UpdateProfileSchema) {}
```

### Users Service Implementation

[Source: architecture/coding-standards.md#nestjs-best-practices]

**UsersService:**

```typescript
import { Injectable, Logger } from '@nestjs/common'
import { PrismaService } from '../prisma/prisma.service'
import { UpdateProfileDto } from './dto/update-profile.dto'

@Injectable()
export class UsersService {
  private readonly logger = new Logger(UsersService.name)

  constructor(private prisma: PrismaService) {}

  async getProfile(userId: string) {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    })

    if (!user) {
      throw new NotFoundException('User not found')
    }

    const { passwordHash: _, ...userWithoutPassword } = user
    return userWithoutPassword
  }

  async updateProfile(userId: string, dto: UpdateProfileDto) {
    const user = await this.prisma.user.update({
      where: { id: userId },
      data: dto,
    })

    this.logger.log(`Profile updated: ${user.email}`)

    const { passwordHash: _, ...userWithoutPassword } = user
    return userWithoutPassword
  }
}
```

### Users Controller Implementation

[Source: architecture/coding-standards.md#nestjs-best-practices]

**UsersController:**

```typescript
import { Controller, Get, Patch, Body } from '@nestjs/common'
import { UsersService } from './users.service'
import { UpdateProfileDto } from './dto/update-profile.dto'
import { CurrentUser } from '../auth/decorators/current-user.decorator'
import { User } from '@prisma/client'

@Controller('me')
export class UsersController {
  constructor(private usersService: UsersService) {}

  @Get()
  async getProfile(@CurrentUser() user: User) {
    return this.usersService.getProfile(user.id)
  }

  @Patch()
  async updateProfile(@CurrentUser() user: User, @Body() dto: UpdateProfileDto) {
    return this.usersService.updateProfile(user.id, dto)
  }
}
```

### CurrentUser Decorator Usage

[Source: prd/epic-2-authentication.md#story-2.4]

**@CurrentUser() decorator** provides access to authenticated user:

- Extracts user from `request.user` (set by JWT strategy)
- User object contains: id, email, displayName, bio, avatarUrl, createdAt, updatedAt
- Password hash is already excluded by JWT strategy

### Partial Updates

[Source: architecture/coding-standards.md#typescript-best-practices]

**Prisma update with partial data:**

```typescript
// Only fields provided in DTO will be updated
await this.prisma.user.update({
  where: { id: userId },
  data: {
    displayName: dto.displayName, // Only if provided
    bio: dto.bio, // Only if provided
    avatarUrl: dto.avatarUrl, // Only if provided
  },
})
```

### Email and Password Updates (Phase 2)

[Source: prd/epic-2-authentication.md#story-2.4]

**Not implemented in MVP:**

- Email update (requires email verification)
- Password change (requires current password confirmation)

**Document for Phase 2:**

```typescript
// TODO: Phase 2 - Email Update
// POST /v1/me/email
// - Require current password
// - Send verification email to new address
// - Update email after verification

// TODO: Phase 2 - Password Change
// POST /v1/me/password
// - Require current password
// - Validate new password strength
// - Hash and update password
```

### Response Format

[Source: prd/epic-2-authentication.md#story-2.4]

**GET /v1/me response:**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "displayName": "John Doe",
  "bio": "Food enthusiast and home cook",
  "avatarUrl": "http://localhost:3001/uploads/profiles/abc-123.jpg",
  "createdAt": "2025-09-30T10:00:00.000Z",
  "updatedAt": "2025-09-30T10:05:00.000Z"
}
```

**PATCH /v1/me request:**

```json
{
  "displayName": "Jane Doe",
  "bio": "Professional chef sharing family recipes"
}
```

**PATCH /v1/me response:**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "displayName": "Jane Doe",
  "bio": "Professional chef sharing family recipes",
  "avatarUrl": "http://localhost:3001/uploads/profiles/abc-123.jpg",
  "createdAt": "2025-09-30T10:00:00.000Z",
  "updatedAt": "2025-09-30T10:10:00.000Z"
}
```

### Validation Error Response

[Source: architecture/coding-standards.md#error-handling]

**400 Bad Request for validation errors:**

```json
{
  "statusCode": 400,
  "message": "Validation failed",
  "errors": [
    {
      "field": "displayName",
      "message": "Display name must be at least 2 characters"
    },
    {
      "field": "bio",
      "message": "Bio must not exceed 500 characters"
    }
  ],
  "timestamp": "2025-09-30T10:00:00.000Z",
  "path": "/v1/me"
}
```

### Testing

[Source: architecture/coding-standards.md#testing-standards]

**Unit Tests:**

```typescript
describe('UsersService', () => {
  describe('getProfile', () => {
    it('should return user without password', async () => {
      // Test implementation
    })

    it('should throw NotFoundException if user not found', async () => {
      // Test implementation
    })
  })

  describe('updateProfile', () => {
    it('should update displayName', async () => {
      // Test implementation
    })

    it('should update bio', async () => {
      // Test implementation
    })

    it('should update avatarUrl', async () => {
      // Test implementation
    })

    it('should update multiple fields', async () => {
      // Test implementation
    })

    it('should validate displayName length', async () => {
      // Test implementation
    })

    it('should validate bio length', async () => {
      // Test implementation
    })

    it('should validate avatarUrl format', async () => {
      // Test implementation
    })
  })
})
```

**Integration Tests:**

```typescript
describe('GET /v1/me', () => {
  it('should return current user profile', async () => {
    const { accessToken } = await login()

    const response = await request(app.getHttpServer())
      .get('/v1/me')
      .set('Authorization', `Bearer ${accessToken}`)
      .expect(200)

    expect(response.body).toHaveProperty('id')
    expect(response.body).toHaveProperty('email')
    expect(response.body).not.toHaveProperty('passwordHash')
  })

  it('should return 401 without authentication', async () => {
    await request(app.getHttpServer()).get('/v1/me').expect(401)
  })
})

describe('PATCH /v1/me', () => {
  it('should update display name', async () => {
    const { accessToken } = await login()

    const response = await request(app.getHttpServer())
      .patch('/v1/me')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ displayName: 'New Name' })
      .expect(200)

    expect(response.body.displayName).toBe('New Name')
  })

  it('should update bio', async () => {
    const { accessToken } = await login()

    const response = await request(app.getHttpServer())
      .patch('/v1/me')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ bio: 'New bio' })
      .expect(200)

    expect(response.body.bio).toBe('New bio')
  })

  it('should return 400 for invalid displayName', async () => {
    const { accessToken } = await login()

    await request(app.getHttpServer())
      .patch('/v1/me')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ displayName: 'A' }) // Too short
      .expect(400)
  })

  it('should return 400 for bio too long', async () => {
    const { accessToken } = await login()

    await request(app.getHttpServer())
      .patch('/v1/me')
      .set('Authorization', `Bearer ${accessToken}`)
      .send({ bio: 'A'.repeat(501) }) // Too long
      .expect(400)
  })

  it('should return 401 without authentication', async () => {
    await request(app.getHttpServer()).patch('/v1/me').send({ displayName: 'New Name' }).expect(401)
  })
})
```

---

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-09-30 | 1.0     | Initial story creation | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent during implementation_

### Debug Log References

_To be filled by Dev Agent during implementation_

### Completion Notes List

_To be filled by Dev Agent during implementation_

### File List

_To be filled by Dev Agent during implementation_

---

## QA Results

_To be filled by QA Agent after implementation_
