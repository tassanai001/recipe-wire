# Story 2.3: JWT Authentication Guard & Token Refresh

**Epic:** Epic 2 - Authentication & User System  
**Story ID:** 2.3  
**Priority:** High  
**Estimate:** 5 Story Points  
**Sprint:** Sprint 2-3 (Week 3-4)

---

## Status

**Draft**

---

## Story

**As a** logged-in user,  
**I want** my session to be maintained securely,  
**so that** I can access protected resources without re-logging in frequently

---

## Acceptance Criteria

1. JWT Authentication Guard created and configured globally
2. Guard validates access token on protected routes:
   - Verify token signature
   - Check expiration
   - Extract user information
   - Attach user to request object
3. `POST /v1/auth/refresh` endpoint created:
   - Accepts refresh token
   - Validates refresh token
   - Issues new access token
   - Returns new access token
4. Error handling:
   - 401 for invalid/expired tokens
   - 403 for missing tokens
5. Public routes excluded from guard:
   - `/v1/auth/signup`
   - `/v1/auth/login`
   - `/health`
6. Unit tests verify token validation logic
7. Integration tests verify protected route access

---

## Tasks / Subtasks

- [ ] **Create JWT Strategy** (AC: 2)
  - [ ] Create `src/auth/strategies/jwt.strategy.ts`
  - [ ] Extend PassportStrategy with 'jwt'
  - [ ] Configure to extract token from Authorization header
  - [ ] Set public key for token verification
  - [ ] Implement validate method to extract user from payload
  - [ ] Return user object from validate method

- [ ] **Create JWT Auth Guard** (AC: 1, 2)
  - [ ] Create `src/auth/guards/jwt-auth.guard.ts`
  - [ ] Extend AuthGuard('jwt')
  - [ ] Override canActivate to add custom logic
  - [ ] Handle missing token → 403 Forbidden
  - [ ] Handle invalid token → 401 Unauthorized
  - [ ] Allow public routes to bypass guard

- [ ] **Create Public Decorator** (AC: 5)
  - [ ] Create `src/auth/decorators/public.decorator.ts`
  - [ ] Define @Public() decorator using SetMetadata
  - [ ] Use IS_PUBLIC_KEY constant
  - [ ] Export decorator

- [ ] **Create CurrentUser Decorator** (AC: 2)
  - [ ] Create `src/auth/decorators/current-user.decorator.ts`
  - [ ] Define @CurrentUser() decorator using createParamDecorator
  - [ ] Extract user from request object
  - [ ] Return user data
  - [ ] Export decorator

- [ ] **Configure Global JWT Guard** (AC: 1)
  - [ ] Register JwtStrategy as provider in AuthModule
  - [ ] Configure APP_GUARD with JwtAuthGuard in AppModule
  - [ ] Set guard as global
  - [ ] Verify guard applies to all routes by default

- [ ] **Update JWT Guard for Public Routes** (AC: 5)
  - [ ] Inject Reflector in JwtAuthGuard
  - [ ] Check for IS_PUBLIC_KEY metadata in canActivate
  - [ ] Return true (allow access) if route is public
  - [ ] Continue with JWT validation if not public

- [ ] **Mark Public Routes** (AC: 5)
  - [ ] Add @Public() to POST /auth/signup
  - [ ] Add @Public() to POST /auth/login
  - [ ] Add @Public() to GET /health
  - [ ] Test public routes accessible without token

- [ ] **Create Refresh Token DTO** (AC: 3)
  - [ ] Create `src/auth/dto/refresh-token.dto.ts`
  - [ ] Define RefreshTokenSchema in @recipe-wire/types
  - [ ] Add refreshToken field with validation
  - [ ] Export DTO

- [ ] **Implement Token Refresh Logic** (AC: 3)
  - [ ] Create `refresh` method in AuthService
  - [ ] Accept RefreshTokenDto
  - [ ] Verify refresh token signature
  - [ ] Extract userId from token payload
  - [ ] Find user in database
  - [ ] Throw UnauthorizedException if user not found
  - [ ] Generate new access token
  - [ ] Return new access token

- [ ] **Implement Refresh Endpoint** (AC: 3, 4)
  - [ ] Create POST /auth/refresh endpoint
  - [ ] Add @Public() decorator (refresh doesn't need auth)
  - [ ] Accept @Body() with RefreshTokenDto
  - [ ] Call authService.refresh()
  - [ ] Return new access token
  - [ ] Handle errors (401 for invalid token)

- [ ] **Create Unit Tests** (AC: 6)
  - [ ] Test JwtStrategy validates token correctly
  - [ ] Test JwtAuthGuard allows public routes
  - [ ] Test JwtAuthGuard blocks unauthenticated requests
  - [ ] Test token refresh with valid token
  - [ ] Test token refresh with invalid token
  - [ ] Test token refresh with expired token
  - [ ] Mock JwtService and PrismaService

- [ ] **Create Integration Tests** (AC: 7)
  - [ ] Test protected route requires authentication
  - [ ] Test protected route with valid token succeeds
  - [ ] Test protected route with invalid token returns 401
  - [ ] Test protected route with expired token returns 401
  - [ ] Test protected route without token returns 403
  - [ ] Test public routes accessible without token
  - [ ] Test POST /v1/auth/refresh with valid refresh token
  - [ ] Test POST /v1/auth/refresh with invalid refresh token

- [ ] **Update Existing Endpoints** (AC: 1)
  - [ ] Verify all non-public endpoints are protected
  - [ ] Test GET /v1/me requires authentication (will be created in 2.4)
  - [ ] Document which routes are public vs protected

---

## Dev Notes

### Previous Story Insights
[Dependency: Story 2.2 - User Login & JWT Token Generation]

Story 2.2 established:
- JWT token generation with RS256
- Access tokens (15 min TTL)
- Refresh tokens (7 day TTL)
- Login endpoint returning tokens

This story implements JWT authentication guard to protect routes and token refresh mechanism.

### Passport JWT Strategy
[Source: architecture/tech-stack.md#jwt]

**JWT Strategy configuration:**
```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { PassportStrategy } from '@nestjs/passport'
import { ExtractJwt, Strategy } from 'passport-jwt'
import { ConfigService } from '@nestjs/config'
import { PrismaService } from '../../prisma/prisma.service'

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private config: ConfigService,
    private prisma: PrismaService
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: config.get('JWT_PUBLIC_KEY'),
      algorithms: ['RS256']
    })
  }

  async validate(payload: { userId: string; email: string }) {
    // Optionally verify user still exists
    const user = await this.prisma.user.findUnique({
      where: { id: payload.userId }
    })

    if (!user) {
      throw new UnauthorizedException('User not found')
    }

    // Return user object (will be attached to request.user)
    const { passwordHash: _, ...userWithoutPassword } = user
    return userWithoutPassword
  }
}
```

### JWT Auth Guard
[Source: prd/epic-2-authentication.md#story-2.3]

**Guard implementation:**
```typescript
import { Injectable, ExecutionContext } from '@nestjs/common'
import { Reflector } from '@nestjs/core'
import { AuthGuard } from '@nestjs/passport'
import { IS_PUBLIC_KEY } from '../decorators/public.decorator'

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super()
  }

  canActivate(context: ExecutionContext) {
    // Check if route is marked as public
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass()
    ])

    if (isPublic) {
      return true
    }

    // Call parent canActivate (Passport JWT)
    return super.canActivate(context)
  }
}
```

### Public Decorator
[Source: architecture/source-tree.md#backend-structure]

**Public decorator implementation:**
```typescript
import { SetMetadata } from '@nestjs/common'

export const IS_PUBLIC_KEY = 'isPublic'
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true)
```

**Usage:**
```typescript
@Controller('auth')
export class AuthController {
  @Public()
  @Post('signup')
  async signup(@Body() dto: SignupDto) {
    // ...
  }

  @Public()
  @Post('login')
  async login(@Body() dto: LoginDto) {
    // ...
  }
}
```

### CurrentUser Decorator
[Source: architecture/source-tree.md#backend-structure]

**CurrentUser decorator implementation:**
```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common'

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest()
    return request.user
  }
)
```

**Usage:**
```typescript
@Get('me')
async getProfile(@CurrentUser() user: User) {
  return user
}
```

### Global Guard Configuration
[Source: prd/epic-2-authentication.md#story-2.3]

**Configure in AppModule:**
```typescript
import { Module } from '@nestjs/common'
import { APP_GUARD } from '@nestjs/core'
import { JwtAuthGuard } from './auth/guards/jwt-auth.guard'

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: JwtAuthGuard
    }
  ]
})
export class AppModule {}
```

### Token Refresh Implementation
[Source: prd/epic-2-authentication.md#story-2.3]

**Refresh token DTO:**
```typescript
export const RefreshTokenSchema = z.object({
  refreshToken: z.string().min(1, 'Refresh token is required')
})

export type RefreshTokenDto = z.infer<typeof RefreshTokenSchema>
```

**AuthService refresh method:**
```typescript
async refresh(dto: RefreshTokenDto) {
  try {
    // Verify refresh token
    const payload = this.jwtService.verify(dto.refreshToken, {
      secret: this.config.get('JWT_PUBLIC_KEY'),
      algorithms: ['RS256']
    })

    // Find user
    const user = await this.prisma.user.findUnique({
      where: { id: payload.userId }
    })

    if (!user) {
      throw new UnauthorizedException('User not found')
    }

    // Generate new access token
    const accessToken = this.jwtService.sign(
      { userId: user.id, email: user.email },
      { expiresIn: '15m' }
    )

    return { accessToken }
  } catch (error) {
    throw new UnauthorizedException('Invalid refresh token')
  }
}
```

**AuthController refresh endpoint:**
```typescript
@Public()
@Post('refresh')
@HttpCode(HttpStatus.OK)
async refresh(@Body() dto: RefreshTokenDto) {
  return this.authService.refresh(dto)
}
```

### Token Extraction
[Source: architecture/tech-stack.md#jwt]

**Token format in request:**
```
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Passport JWT extracts token automatically** using `ExtractJwt.fromAuthHeaderAsBearerToken()`

### Protected vs Public Routes
[Source: prd/epic-2-authentication.md#story-2.3]

**Public routes (no authentication required):**
- `POST /v1/auth/signup`
- `POST /v1/auth/login`
- `POST /v1/auth/refresh`
- `GET /health`

**Protected routes (authentication required):**
- `GET /v1/me` (Story 2.4)
- `PATCH /v1/me` (Story 2.4)
- All future recipe, review endpoints

### Error Responses
[Source: architecture/coding-standards.md#error-handling]

**401 Unauthorized (invalid/expired token):**
```json
{
  "statusCode": 401,
  "message": "Unauthorized",
  "timestamp": "2025-09-30T10:00:00.000Z",
  "path": "/v1/me"
}
```

**403 Forbidden (missing token):**
```json
{
  "statusCode": 403,
  "message": "Forbidden resource",
  "timestamp": "2025-09-30T10:00:00.000Z",
  "path": "/v1/me"
}
```

### Security Considerations
[Source: prd/epic-2-authentication.md#security-considerations]

**JWT Security:**
- Verify token signature on every request
- Check token expiration
- Use RS256 (asymmetric) for better security
- Don't store sensitive data in JWT payload
- Validate user still exists in database (optional, adds DB query)

**Refresh Token Security (Phase 2):**
- Store refresh tokens in database
- Implement token rotation (issue new refresh token on refresh)
- Implement token revocation
- Track token usage for security monitoring

### Testing

[Source: architecture/coding-standards.md#testing-standards]

**Unit Tests:**
```typescript
describe('JwtAuthGuard', () => {
  it('should allow access to public routes', () => {
    // Test implementation
  })

  it('should block access without token', () => {
    // Test implementation
  })

  it('should allow access with valid token', () => {
    // Test implementation
  })

  it('should block access with invalid token', () => {
    // Test implementation
  })
})

describe('AuthService - refresh', () => {
  it('should return new access token for valid refresh token', () => {
    // Test implementation
  })

  it('should throw UnauthorizedException for invalid refresh token', () => {
    // Test implementation
  })

  it('should throw UnauthorizedException for expired refresh token', () => {
    // Test implementation
  })
})
```

**Integration Tests:**
```typescript
describe('Protected Routes', () => {
  it('should return 403 without token', async () => {
    await request(app.getHttpServer())
      .get('/v1/me')
      .expect(403)
  })

  it('should return 401 with invalid token', async () => {
    await request(app.getHttpServer())
      .get('/v1/me')
      .set('Authorization', 'Bearer invalid-token')
      .expect(401)
  })

  it('should return 200 with valid token', async () => {
    const { accessToken } = await login()

    await request(app.getHttpServer())
      .get('/v1/me')
      .set('Authorization', `Bearer ${accessToken}`)
      .expect(200)
  })
})

describe('POST /v1/auth/refresh', () => {
  it('should return new access token', async () => {
    const { refreshToken } = await login()

    const response = await request(app.getHttpServer())
      .post('/v1/auth/refresh')
      .send({ refreshToken })
      .expect(200)

    expect(response.body).toHaveProperty('accessToken')
  })

  it('should return 401 for invalid refresh token', async () => {
    await request(app.getHttpServer())
      .post('/v1/auth/refresh')
      .send({ refreshToken: 'invalid-token' })
      .expect(401)
  })
})
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-30 | 1.0 | Initial story creation | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used
_To be filled by Dev Agent during implementation_

### Debug Log References
_To be filled by Dev Agent during implementation_

### Completion Notes List
_To be filled by Dev Agent during implementation_

### File List
_To be filled by Dev Agent during implementation_

---

## QA Results

_To be filled by QA Agent after implementation_
